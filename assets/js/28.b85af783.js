(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{308:function(_,v,s){"use strict";s.r(v);var t=s(14),l=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"q-主从复制的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-主从复制的作用"}},[_._v("#")]),_._v(" q: 主从复制的作用?")]),_._v(" "),v("p",[_._v("主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。")]),_._v(" "),v("ul",[v("li",[_._v("第1个作用：读写分离。")])]),_._v(" "),v("p",[_._v("我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141802.png",alt:"image.png"}})]),_._v(" "),v("p",[_._v("其中一个是Master主库，负责写入数据，我们称之为:写库。")]),_._v(" "),v("p",[_._v("其它都是slave从库，负责读取数据，我们称之为:读库。")]),_._v(" "),v("p",[_._v('当主库进行更新的时候，会自动将数据复制到从库中，而在客户端读取数据的时候，会从从库中进行读取。面对“读多写少"的需求，采用读写分离的方式，可以实现更高的并发访问。同时还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。')]),_._v(" "),v("ul",[v("li",[_._v("第2个作用就是"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("数据备份"),v("OutboundLink")],1)])]),_._v(" "),v("p",[_._v("第2个作用就是数据备份。通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务")]),_._v(" "),v("ul",[v("li",[_._v("第3个作用是具有高可用性")])]),_._v(" "),v("p",[_._v("第3个作用是具有高可用性。数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。")]),_._v(" "),v("p",[_._v("关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间/全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过365"),v("em",[_._v("24")]),_._v("68*(1-99.999%)=5.256分钟(含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态。")]),_._v(" "),v("p",[_._v("实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中需要结合业务需求和成本来进行选择。")]),_._v(" "),v("h2",{attrs:{id:"q-主从复制的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-主从复制的原理"}},[_._v("#")]),_._v(" q: 主从复制的原理?")]),_._v(" "),v("p",[_._v("Slave 会从 Master 读取 "),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=binlog&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("binlog"),v("OutboundLink")],1),_._v(" 来进行数据同步。")]),_._v(" "),v("p",[v("strong",[_._v("三个线程")]),_._v("\n实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程 来操作，一个主库线程，两个从库线程。\n"),v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141825.png",alt:"image.png"}})]),_._v(" "),v("ul",[v("li",[_._v("二进制日志转储线程 （Binlog dump thread）")])]),_._v(" "),v("p",[_._v("二进制日志转储线程 （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。二进制日志转储线程负责将数据发送出去。")]),_._v(" "),v("ul",[v("li",[_._v("从库 I/O 线程")])]),_._v(" "),v("p",[_._v("从库 I/O 线程 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。")]),_._v(" "),v("ul",[v("li",[_._v("从库 SQL 线程")])]),_._v(" "),v("p",[_._v("从库 SQL 线程 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。\n"),v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141838.png",alt:"image.png"}})]),_._v(" "),v("p",[_._v("复制三步骤")]),_._v(" "),v("ul",[v("li",[_._v("步骤1： Master 将写操作记录到二进制日志（ binlog ）。")]),_._v(" "),v("li",[_._v("步骤2： Slave 将 Master 的binary log events拷贝到它的中继日志（ relay log ）；")]),_._v(" "),v("li",[_._v("步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点 开始复制。")])]),_._v(" "),v("h2",{attrs:{id:"q-同步数据一致性问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-同步数据一致性问题"}},[_._v("#")]),_._v(" q:同步数据一致性问题")]),_._v(" "),v("p",[v("strong",[_._v("主从同步的要求：")])]),_._v(" "),v("ul",[v("li",[_._v("读库和写库的数据一致(最终一致)；")]),_._v(" "),v("li",[_._v("写数据必须写到写库；")]),_._v(" "),v("li",[_._v("读数据必须到读库(不一定)；")])]),_._v(" "),v("p",[v("strong",[_._v("理解主从延迟问题")])]),_._v(" "),v("p",[_._v("进行主从同步的内容是二进制日志，它是一个文件，在进行网络传输的过程中就一定会存在主从延迟(比如50oms)，这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的数据不一致性问题。")]),_._v(" "),v("p",[_._v("举例:导致主从延迟的时间点主要包括以下三个:")]),_._v(" "),v("ol",[v("li",[_._v("主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;")]),_._v(" "),v("li",[_._v("之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;")]),_._v(" "),v("li",[_._v("从库B执行完成这个事务，我们把这个时刻记为T3。")])]),_._v(" "),v("p",[v("strong",[_._v("主从延迟问题原因")]),_._v(":")]),_._v(" "),v("p",[_._v("在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。")]),_._v(" "),v("p",[_._v("主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。造成原因：")]),_._v(" "),v("p",[_._v("1、从库的机器性能比主库要差")]),_._v(" "),v("p",[_._v("2、从库的压力大")]),_._v(" "),v("p",[_._v("3、大事务的执行")]),_._v(" "),v("p",[_._v("举例1：一次性用delete语句删除太多数据")]),_._v(" "),v("p",[_._v("结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。")]),_._v(" "),v("p",[_._v("举例2：一次性用insert…select插入太多数据")]),_._v(" "),v("p",[_._v("举例:3：大表DDL")]),_._v(" "),v("p",[_._v("比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟。")]),_._v(" "),v("p",[_._v("4.3 如何减少主从延迟")]),_._v(" "),v("p",[_._v("若想要减少主从延迟的时间，可以采取下面的办法：")]),_._v(" "),v("ol",[v("li",[_._v("降低多线程大事务并发的概率，优化业务逻辑")]),_._v(" "),v("li",[_._v("优化SQL，避免慢SQL， 减少批量操作 ，建议写脚本以update-sleep这样的形式完成。")]),_._v(" "),v("li",[_._v("提高从库机器的配置 ，减少主库写binlog和从库读binlog的效率差。")]),_._v(" "),v("li",[_._v("尽量采用 短的链路 ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。")]),_._v(" "),v("li",[_._v("实时性要求的业务读强制走主库，从库只做灾备，备份。")])]),_._v(" "),v("p",[_._v("如何解决一致性问题?")]),_._v(" "),v("p",[_._v("如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份 ，并没有起到读写分离 ，分担主库读压力的作用。\n"),v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141854.png",alt:"image.png"}})]),_._v(" "),v("p",[_._v("读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。")]),_._v(" "),v("ul",[v("li",[_._v("方法 1：异步复制")])]),_._v(" "),v("p",[_._v("异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141912.png",alt:"image.png"}})]),_._v(" "),v("ul",[v("li",[_._v("方法 2：半同步复制")])]),_._v(" "),v("p",[_._v("MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。")]),_._v(" "),v("p",[_._v("这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。")]),_._v(" "),v("p",[_._v("在MySQL5.7版本中还增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141932.png",alt:"image.png"}})]),_._v(" "),v("ul",[v("li",[_._v("方法 3：组复制")])]),_._v(" "),v("p",[_._v("异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。")]),_._v(" "),v("p",[_._v("组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。")]),_._v(" "),v("h2",{attrs:{id:"q-如何实现读写分离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-如何实现读写分离"}},[_._v("#")]),_._v(" q: 如何实现读写分离？")]),_._v(" "),v("p",[_._v("在主从架构的配置中，如果想要采取读写分离的策略，我们可以自己编写程序 ，也可以通过第三方的中间件来实现。")]),_._v(" "),v("ul",[v("li",[_._v("自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。")]),_._v(" "),v("li",[_._v("采用中间件的方法有很明显的优势，功能强大 ，使用简单 。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141954.png",alt:"image.png"}})]),_._v(" "),v("p",[_._v("Mycat 是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。")])])}),[],!1,null,null,null);v.default=l.exports}}]);