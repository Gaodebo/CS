<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>程序员加文</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="程序员加文的Java技术学习分享网站">
    
    <link rel="preload" href="/cs/assets/css/0.styles.3da77e5f.css" as="style"><link rel="preload" href="/cs/assets/js/app.3833f9ea.js" as="script"><link rel="preload" href="/cs/assets/js/2.3dc1b8de.js" as="script"><link rel="preload" href="/cs/assets/js/1.54be531d.js" as="script"><link rel="preload" href="/cs/assets/js/29.4ef018b1.js" as="script"><link rel="prefetch" href="/cs/assets/js/10.563984b0.js"><link rel="prefetch" href="/cs/assets/js/11.c389195a.js"><link rel="prefetch" href="/cs/assets/js/12.81539b0f.js"><link rel="prefetch" href="/cs/assets/js/13.21c635b9.js"><link rel="prefetch" href="/cs/assets/js/14.37ef2a72.js"><link rel="prefetch" href="/cs/assets/js/15.5542c093.js"><link rel="prefetch" href="/cs/assets/js/16.d48fd1ce.js"><link rel="prefetch" href="/cs/assets/js/17.bd8d538c.js"><link rel="prefetch" href="/cs/assets/js/18.6d3b94c1.js"><link rel="prefetch" href="/cs/assets/js/19.eb35cfee.js"><link rel="prefetch" href="/cs/assets/js/20.7d8a0e52.js"><link rel="prefetch" href="/cs/assets/js/21.db1b5d88.js"><link rel="prefetch" href="/cs/assets/js/22.7b484c1b.js"><link rel="prefetch" href="/cs/assets/js/23.37dd5e12.js"><link rel="prefetch" href="/cs/assets/js/24.b0fcefbf.js"><link rel="prefetch" href="/cs/assets/js/25.39c9b679.js"><link rel="prefetch" href="/cs/assets/js/26.ac34285f.js"><link rel="prefetch" href="/cs/assets/js/27.b46debc5.js"><link rel="prefetch" href="/cs/assets/js/28.b85af783.js"><link rel="prefetch" href="/cs/assets/js/3.5322f14a.js"><link rel="prefetch" href="/cs/assets/js/30.993eb757.js"><link rel="prefetch" href="/cs/assets/js/31.531d8767.js"><link rel="prefetch" href="/cs/assets/js/32.89255c8b.js"><link rel="prefetch" href="/cs/assets/js/33.b8f4cef1.js"><link rel="prefetch" href="/cs/assets/js/34.263694d3.js"><link rel="prefetch" href="/cs/assets/js/35.6cc43691.js"><link rel="prefetch" href="/cs/assets/js/36.f36ea129.js"><link rel="prefetch" href="/cs/assets/js/37.e7d013d3.js"><link rel="prefetch" href="/cs/assets/js/38.2836e84c.js"><link rel="prefetch" href="/cs/assets/js/4.84e1e480.js"><link rel="prefetch" href="/cs/assets/js/5.f0541060.js"><link rel="prefetch" href="/cs/assets/js/6.dfb06aa0.js"><link rel="prefetch" href="/cs/assets/js/7.7551a9fb.js"><link rel="prefetch" href="/cs/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/cs/assets/css/0.styles.3da77e5f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/cs/" class="home-link router-link-active"><img src="/cs/logo.png" alt="程序员加文" class="logo"> <span class="site-name can-hide">程序员加文</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/cs/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/cs/计算机基础/数据库/面试题/基础/数据库.html" class="nav-link">
  面试题
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/cs/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/cs/计算机基础/数据库/面试题/基础/数据库.html" class="nav-link">
  面试题
</a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>逻辑架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>索引</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>事务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs/计算机基础/数据库/面试题/事务/事务.html" class="active sidebar-link">事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-什么是事务" class="sidebar-link">q: 什么是事务?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-事务的特性acid" class="sidebar-link">q: 事务的特性ACID?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-事务的四种特性到底是基于什么机制实现呢" class="sidebar-link">q:事务的四种特性到底是基于什么机制实现呢?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-事务并发问题" class="sidebar-link">q: 事务并发问题?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-事务有哪些隔离级别" class="sidebar-link">q:事务有哪些隔离级别？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-mysql-undo日志和redo日志比较" class="sidebar-link">q:Mysql undo日志和redo日志比较？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-为什么需要redo日志" class="sidebar-link">q: 为什么需要REDO日志</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-redo-log的整体流程" class="sidebar-link">q: redo log的整体流程？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-redo-file的书写策略" class="sidebar-link">q: redo file的书写策略？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-为什么要undo日志" class="sidebar-link">q: 为什么要Undo日志？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-undo的类型" class="sidebar-link">q: undo的类型?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-undo-log的生成过程" class="sidebar-link">q: undo log的生成过程?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-undo-log是如何回滚的" class="sidebar-link">q: undo log是如何回滚的?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-undo-log的删除机制" class="sidebar-link">q: undo log的删除机制？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-mysql还有哪些日志" class="sidebar-link">q: mysql还有哪些日志？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-什么是二进制日志-bin-log" class="sidebar-link">q: 什么是二进制日志(bin log)</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-binlog的写入机制" class="sidebar-link">q: binlog的写入机制？</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-binlog与redolog对比" class="sidebar-link">q: binlog与redolog对比?</a></li><li class="sidebar-sub-header"><a href="/cs/计算机基础/数据库/面试题/事务/事务.html#q-如何理解两阶段提交" class="sidebar-link">q: 如何理解两阶段提交？</a></li></ul></li><li><a href="/cs/计算机基础/数据库/面试题/事务/多版本并发控制.html" class="sidebar-link">多版本并发控制</a></li><li><a href="/cs/计算机基础/数据库/面试题/事务/锁.html" class="sidebar-link">锁</a></li><li><a href="/cs/计算机基础/数据库/面试题/事务/主从复制.html" class="sidebar-link">主从复制</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/5dd3955a7726958cf87f6830c0911a9.jpg" alt="5dd3955a7726958cf87f6830c0911a9.jpg"> <img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230802202548.png" alt="image.png"></p> <h2 id="q-什么是事务"><a href="#q-什么是事务" class="header-anchor">#</a> q: 什么是事务?</h2> <p>事务是一组操作，使数据从一种安全状态变为另一种安全状态</p> <blockquote><p>在MysQL中，只有InnoDB是支持事务的</p></blockquote> <h2 id="q-事务的特性acid"><a href="#q-事务的特性acid" class="header-anchor">#</a> q: 事务的特性ACID?</h2> <p><strong>原子性</strong>
（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p> <p><strong>一致性</strong>
（Consistency）
事务必须使数据库从一个合法的（满足约束）的状态变换到另外一个合法的状态。
事务完成时，必须使所有数据都保持一致状态
或者可以理解为：多个事务并发执行的结果和串行执行的结果是一致的</p> <p><strong>隔离性</strong>
（Isolation）
事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p> <p><strong>持久性</strong>
（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p> <h2 id="q-事务的四种特性到底是基于什么机制实现呢"><a href="#q-事务的四种特性到底是基于什么机制实现呢" class="header-anchor">#</a> q:事务的四种特性到底是基于什么机制实现呢?</h2> <ul><li>事务的隔离性由锁机制和MVCC实现</li> <li>事务的原子性是由undo日志来保证</li> <li>事务的持久性是由redo日志保证</li> <li>事务的一致性是由隔离性和原子性和持久性一起实现</li></ul> <h2 id="q-事务并发问题"><a href="#q-事务并发问题" class="header-anchor">#</a> q: 事务并发问题?</h2> <p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141201.png" alt="image.png"></p> <p><strong>写-写</strong></p> <ul><li><p>丢失修改（脏写）</p> <blockquote><p>由于并发交替执行的操作，可能导致某一事物的修改被覆盖</p></blockquote></li></ul> <p><strong>读-写</strong></p> <ul><li><p>不能重复读：</p> <p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p> <blockquote><p>在一个事务过程中，由于另一个事务<strong>修改</strong>数据，造成该事务前后读取数据不一致</p></blockquote></li> <li><p>幻读:</p> <p>幻读指的是事务不是串行 发生时的一种现象，是事务 A读取了事务B已提交的新 增数据。例如第一个事务对 一个表的所有数据进行修 改，同时第二个事务向表中 插入一条新数据。那么操作 第一个事务的用户就发现表 中还有没有修改的数据行， 就像发生了幻觉一样。解决 幻读的方法是增加范围锁 （range lock）或者表锁。</p> <blockquote><p>在一个事务过程中，由于另一个事务<strong>插入或删除</strong>记录，造成该事务前后读取总的记录数不一致</p></blockquote></li> <li><p>脏读：</p> <p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p> <blockquote><p>一个事务读取了另一个事务尚未提交的数据</p></blockquote></li></ul> <h2 id="q-事务有哪些隔离级别"><a href="#q-事务有哪些隔离级别" class="header-anchor">#</a> q:事务有哪些隔离级别？</h2> <p>事务的隔离机制就是解决读写冲突的一个手段。</p> <p><img src="http://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230301164339.png" alt="image.png"></p> <p>不论是哪种隔离级别，都不允许脏写的情况发生。 不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差</p> <p><strong>读未提交</strong>
存在问题：</p> <ul><li>脏写</li> <li>脏读</li> <li>不可重复读</li> <li>幻读</li></ul> <p>原因解释：</p> <ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzQ2MDg4Nw==&amp;mid=2247483812&amp;idx=1&amp;sn=dc24a2c69481b27b08da6199be654e07&amp;chksm=ec708f5cdb07064a1f00f12a9fbfa5e278b0721d7d766c0c189d9e05250a1255557313a63a4b&amp;cur_album_id=1445831294184767489&amp;scene=190#rd" target="_blank" rel="noopener noreferrer">图解脏写、脏读、不可重复读、幻读 (qq.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>读已提交</strong>
解决问题：</p> <ul><li>脏写</li> <li>脏读</li></ul> <p>存在问题</p> <ul><li>不可重复读</li> <li>幻读</li></ul> <p><strong>可重复读</strong>
（mysql默认）
解决问题：</p> <ul><li>脏写</li> <li>脏读</li> <li>不可重复读</li></ul> <p>存在问题</p> <ul><li>幻读</li></ul> <p><strong>串行化</strong>
解决问题</p> <ul><li>脏写</li> <li>脏读</li> <li>不可重复读</li> <li>幻读</li></ul> <h2 id="q-mysql-undo日志和redo日志比较"><a href="#q-mysql-undo日志和redo日志比较" class="header-anchor">#</a> q:Mysql undo日志和redo日志比较？</h2> <p>1）REDO LOG称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。
2）UNDO LOG称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p> <p>有的DBA或许会认为UNDO是REDO的逆过程，其实不然。REDO和UNDO都可以视为是一种恢复操作。但是:</p> <ul><li><p>redo log：是存储引擎层(innodb)生成的日志，记录的是&quot;物理级别&quot;上的页修改操作，比如页号xxx、偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性</p></li> <li><p>undo log:是存储引擎层(innodb)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚(undo log 记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本–MVCC，即多版本并发控制）</p></li></ul> <h2 id="q-为什么需要redo日志"><a href="#q-为什么需要redo日志" class="header-anchor">#</a> q: 为什么需要REDO日志</h2> <p>InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（ checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p> <p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p> <p>另一方面，事务包含 持久性 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p> <p>那么如何保证这个持久性呢？ 一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p> <ul><li><strong>修改量与刷新磁盘工作量严重不成比例</strong>
有时候仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说在该事务提交时不得不将一个完整的页面从内存中刷新到慈盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</li> <li><strong>随机IO刷新较慢</strong>
一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li></ul> <p>另一个解决的思路∶我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的值更新为2。</p> <p>InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging )，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通i过redo log来恢复，保证ACID中的D，
这就是redo log的作用。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141222.png" alt="image.png"></p> <blockquote><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote> <p>REDO日志的好处、特点</p> <p><strong>1. 好处</strong></p> <ul><li>redo日志降低了刷盘频率</li> <li>redo日志占用的空间非常小</li></ul> <p><strong>2.特点</strong></p> <ul><li>redo日志是顺序写入磁盘的
在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的l顺序写入磁盘的，也就是使用顺序IO，效率比随机lO快。</li> <li>事务执行过程中，redo log不断记录
redo log跟bin log的区别,redo log是存储引擎层产生的，而bin log是数据库层产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中</li></ul> <h2 id="q-redo-log的整体流程"><a href="#q-redo-log的整体流程" class="header-anchor">#</a> q: redo log的整体流程？</h2> <p>以一个更新事务为例，redo log 流转过程，如下图所示：
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141245.png" alt="image.png"></p> <p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值
第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式
第4步：定期将内存中修改的数据刷新到磁盘中</p> <p>刷盘策略
innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p> <ul><li><p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p></li> <li><p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</p></li> <li><p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230702194958.png" alt="image.png"></p></li></ul> <p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache ) ，然后调用刷盘操作。</p> <h2 id="q-redo-file的书写策略"><a href="#q-redo-file的书写策略" class="header-anchor">#</a> q: redo file的书写策略？</h2> <p>多个redo file组成一个文件组，在一个组内循环写入
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230820122824.png" alt="image.png"></p> <p>有两个指针，分别记录写入的和已经刷到磁盘的位置
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230820122902.png" alt="image.png">
如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p> <h2 id="q-为什么要undo日志"><a href="#q-为什么要undo日志" class="header-anchor">#</a> q: 为什么要Undo日志？</h2> <p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log 。</p> <p>事务需要保证 原子性 ，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p> <ul><li>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突然 断电 导致的错误。</li> <li>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行。</li></ul> <p>以上情况出现，需要把数据改回原先的样子，这个过程称之为回滚 ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求</p> <p>每当我们要对一条记录做改动时(这里的改动可以指INSERT、DELETE、UPDATE ），都需要&quot;留一手&quot;—&gt;把回滚时所需的东西记下来。比如:</p> <ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删除就好了（对于每个INSERT，
InnoDB存储引擎会完成一个DELETE)</li> <li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE，InnoDB存储引擎会执行一个INSERT)</li> <li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul> <p>MySQL把这些为了回滚而记录的这些内容称之为撒销日志或者回滚日志(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志</p> <blockquote><p>此外，undo log 会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护</p></blockquote> <p><strong>Undo日志的作用</strong>:</p> <ul><li><h5 id="作用1-回滚数据"><a href="#作用1-回滚数据" class="header-anchor">#</a> 作用1：回滚数据</h5></li></ul> <p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p> <p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p> <ul><li><h5 id="作用2-mvcc"><a href="#作用2-mvcc" class="header-anchor">#</a> 作用2：MVCC</h5></li></ul> <p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取</p> <p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断</p> <h2 id="q-undo的类型"><a href="#q-undo的类型" class="header-anchor">#</a> q: undo的类型?</h2> <p>在InnoDB存储引擎中，undo log分为：</p> <ul><li>insert undo log
insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作</li> <li>update undo log
update undo log记录的是对delete和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除</li></ul> <h2 id="q-undo-log的生成过程"><a href="#q-undo-log的生成过程" class="header-anchor">#</a> q: undo log的生成过程?</h2> <p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141312.png" alt="image.png"></p> <p>以下是undo+redo事务的简化i过程
假设有2个数值，分别为A=1和B=2，然后将A修改为3,B修改为4</p> <div class="language-sql extra-class"><pre class="language-sql"><code> <span class="token operator">-</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>
<span class="token number">2</span>．记录A<span class="token operator">=</span><span class="token number">1</span>到undo log<span class="token punctuation">;</span>
 <span class="token operator">-</span> <span class="token keyword">update</span> A <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token number">4.</span>记录A<span class="token operator">=</span><span class="token number">3</span> 到redo log<span class="token punctuation">;</span>
<span class="token number">5</span>．记录B<span class="token operator">=</span><span class="token number">2</span>到undo log<span class="token punctuation">;</span>
 <span class="token operator">-</span> <span class="token keyword">update</span> B <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token number">7.</span>记录B <span class="token operator">=</span><span class="token number">4</span>到redo log<span class="token punctuation">;</span>
<span class="token number">8</span>．将redo log刷新到磁盘
 <span class="token operator">-</span> <span class="token keyword">commit</span>

</code></pre></div><ul><li>在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响</li> <li>如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化</li> <li>若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘</li></ul> <p>只有Buffer Pool的流程：
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141330.png" alt="image.png"></p> <p>有了Redo Log和Undo Log之后：
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141347.png" alt="image.png"></p> <p>在更新Buffer Pool中的数据之前，需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，就可以通过Undo Log来回滚到事务开始前。</p> <p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p> <ul><li><p>DB_ROW_ID:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键</p></li> <li><p>DB_TRX_ID:每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中</p></li> <li><p>DB_ROLL_PTR;回滚指针，本质上就是指句undo log的指针
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141406.png" alt="image.png"></p> <p><code>当我们执行INSERT时：</code></p></li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span>
</code></pre></div><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…。那么在进行rollback的时候，通过主键直接把对应的数据删除即可</p> <p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141425.png" alt="image.png"></p> <p><code>当我们执行UPDATE时：</code>
对于更新的操作会产生update undo log，并且会分更新主键的和不更新主键的，假设现在执行:</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> name<span class="token operator">=</span> <span class="token string">&quot;Sun&quot;</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">1</span>
</code></pre></div><p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141730.png" alt="image.png"></p> <p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no=0) .
假设现在执行:</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">1</span>
</code></pre></div><p><img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141712.png" alt="image.png"></p> <p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增</p> <p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到原始数据</p> <h2 id="q-undo-log是如何回滚的"><a href="#q-undo-log是如何回滚的" class="header-anchor">#</a> q: undo log是如何回滚的?</h2> <p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p> <ol><li>通过undo no=3的日志把id=2的数据删除</li> <li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li> <li>通过undo no=1的日志把id=1的数据的name还原成Tom</li> <li>通过undo no=0的日志把id=1的数据删除</li></ol> <h2 id="q-undo-log的删除机制"><a href="#q-undo-log的删除机制" class="header-anchor">#</a> q: undo log的删除机制？</h2> <ul><li>针对于insert undo log
因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删
除，不需要进行purge操作。</li> <li>针对于update undo log
该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul> <blockquote><p>补充:
purge线程两个主要作用是:清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种&quot;假删除&quot;;只是做了个标记，真正的删除工作需要后台purge线程去完成
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20230805220520.png" alt="image.png"></p></blockquote> <h2 id="q-mysql还有哪些日志"><a href="#q-mysql还有哪些日志" class="header-anchor">#</a> q: mysql还有哪些日志？</h2> <p><code>慢查询日志:</code>记录所有执行时间超过long_query_time的所有查询，方便对查询进行优化。
<code>通用查询日志:</code>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
<code>错误日志:</code>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而从而对服务器进行维护。
<code>二进制日志:</code>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
<code>中继日志:</code>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
<code>数据定义语句日志:</code>记录数据定义语句执行的元数据操作。除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。</p> <h2 id="q-什么是二进制日志-bin-log"><a href="#q-什么是二进制日志-bin-log" class="header-anchor">#</a> q: 什么是二进制日志(bin log)</h2> <p>binlog可以说是MySQL中比较 重要 的日志了，在日常开发及运维过程中，经常会遇到。</p> <p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p> <p>它以事件形式记录并保存在二进制文件中。通过这些信息，我们可以再现数据更新操作的全过程。</p> <p>如果想要记录所有语句（例如，为了识别有问题的查询)，需要使用通用查询日志。</p> <p><strong>binlog主要应用场景:</strong></p> <ul><li>一是用于数据恢复，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li> <li>二是用于数据复制，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据—致的目的。</li></ul> <p><strong>binlog主要应用场景：</strong></p> <ul><li>一是用于数据恢复</li> <li>二是用于数据复制</li></ul> <p>可以说MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据—致性。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141445.png" alt="image.png"></p> <h2 id="q-binlog的写入机制"><a href="#q-binlog的写入机制" class="header-anchor">#</a> q: binlog的写入机制？</h2> <p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p> <p>我们可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘(Swap)。binlog日志刷盘流程如下:
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141650.png" alt="image.png"></p> <blockquote><p>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快
上图的 fsync，才是将数据持久化到磁盘的操作</p></blockquote> <p>write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。如下图：
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141629.png" alt="image.png"></p> <p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同redo log 刷盘流程一样。</p> <p>最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141612.png" alt="image.png"></p> <p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p> <h2 id="q-binlog与redolog对比"><a href="#q-binlog与redolog对比" class="header-anchor">#</a> q: binlog与redolog对比?</h2> <ul><li>redo log 它是 物理日志 ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li> <li>而 binlog 是逻辑日志 ，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于 MySQL Server层。</li></ul> <p>虽然它们都属于持久化的保证，但是侧重点不同。</p> <ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力</li> <li>binlog 保证了MySQL集群架构的数据一致性。</li></ul> <h2 id="q-如何理解两阶段提交"><a href="#q-如何理解两阶段提交" class="header-anchor">#</a> q: 如何理解两阶段提交？</h2> <p>redo log与binlog不一致，怎么办？</p> <p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机 不一样</p> <p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141554.png" alt="image.png"></p> <p>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redolog还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141538.png" alt="image.png"></p> <p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？
<img src="https://obs-knowledge.oss-cn-beijing.aliyuncs.com/img/20231027141523.png" alt="image.png"></p> <p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cs/计算机基础/数据库/面试题/索引/数据库调优.html" class="prev">
        数据库调优
      </a></span> <span class="next"><a href="/cs/计算机基础/数据库/面试题/事务/多版本并发控制.html">
        多版本并发控制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/cs/assets/js/app.3833f9ea.js" defer></script><script src="/cs/assets/js/2.3dc1b8de.js" defer></script><script src="/cs/assets/js/1.54be531d.js" defer></script><script src="/cs/assets/js/29.4ef018b1.js" defer></script>
  </body>
</html>
